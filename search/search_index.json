{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"Developer/","title":"Overview","text":"<p>This is the internal developer documentation.</p> <p>Every use of this software should begin with creating a new package from the template using <code>&gt;ros create &lt;name&gt;</code>.</p> <p>Generally, there are two main use cases in mind for this software. Often, but not always, these are performed concurrently.</p> <ol> <li> <p>Analyzing data (as in, a research project)</p> </li> <li> <p>Creating new data analysis packages (as in, creating a new tool for others to use)</p> </li> </ol>"},{"location":"Developer/#packages","title":"Packages","text":"<p>Describes how the package dependencies are specified and organized.</p>"},{"location":"Developer/#compilation","title":"Compilation","text":"<p>Describes how the Directed Acyclic Graph (DAG) is compiled from the .toml settings files across packages.</p>"},{"location":"Developer/#running","title":"Running","text":"<p>Describes the process of running the code on the specified dataset.</p>"},{"location":"Developer/Bridges/","title":"Overview","text":"<p>Bridges are the mechanism by which packages that have been built independently can be connected to one another to form a cohesive data processing pipeline. They are defined in the <code>bridges.toml</code> file in each package's folder. A missing <code>bridges.toml</code> file in a package indicates that by default that package does not depend on any other packages. The value of any Unspecified variables must then be listed in each project's <code>bridges.toml</code> file.</p> <p>For example, a simple package to compute, plot, and summarize linear momentum (p) given a velocity (v) and mass (m) (<code>p = m * v</code>) may be missing a <code>bridges.toml</code> file entirely, because the package's computations are self-contained. When this package is then used in a data analysis project, that project's <code>bridges.toml</code> file will specify which variables from the other functions in the pipeline should be used as the inputs to linear momentum computations.</p>"},{"location":"Developer/Bridges/bridges_toml/","title":"Bridges.toml","text":"<p>Describes the structure of the <code>bridges.toml</code> file, which is used to configure bridges. This file is used to connect packages together in a data processing pipeline. </p> <p>Note that even variables that already have values specified in an earlier <code>bridges.toml</code> file will be overwritten if specified here.</p>"},{"location":"Developer/Bridges/bridges_toml/#dynamic-variables","title":"Dynamic Variables","text":"<p>Dynamic variables should be specified using \"input\" format, with multiple source variables and one target variable. The below example bridge shows two source variables connecting to a target variable. This means that the downstream pipeline will be split, with one branch for each source variable.</p> <pre><code>[example_bridge_name]\nsources = [\n    \"source_package_name1.source_process_name1.source_variable_name1\",\n    \"source_package_name2.source_process_name2.source_variable_name2\",\n]\n\ntargets = [\n    \"target_package_name1.target_process_name1.target_variable_name1\",\n]\n</code></pre>"},{"location":"Developer/Bridges/bridges_toml/#hard-coded-variables","title":"Hard-Coded Variables","text":"<p>Hard-coded variables should also be specified with the \"input\" format. Note that the sources are simply hard-coded values. If a list of multiple values are provided, then the downstream pipeline will be split, with one branch for each value. <pre><code>[example_hard_coded_bridge_name]\nsources = [\n    0, 1, 2,\n]\ntargets = [\n    \"target_package_name1.target_process_name1.target_variable_name1\",\n]\n</code></pre></p> <p>If a list is intended to be the input, then encapsulate the list with additional brackets. The below example provides two versions of the same input: a list, and a scalar. <pre><code>[example_hard_coded_bridge_name]\nsources = [\n    [0, 1, 2],\n    3\n]\ntargets = [\n    \"target_package_name1.target_process_name1.target_variable_name1\",\n]\n</code></pre></p>"},{"location":"Developer/Compilation/","title":"Overview","text":"<p>Compilation is the process of reading each package's <code>pyproject.toml</code> file and constructing a Directed Acylic Graph (DAG) that represents the flow of data in the data processing pipeline.</p> <p>Compilation consist of two steps. Step one (Connectivity) constructs the shape of the DAG, relying only on the inputs, outputs, and bridges of each package. Step two (Running) applies all of the metadata to the nodes of the DAG.</p>"},{"location":"Developer/Compilation/connectivity/","title":"Connectivity","text":"<p>To construct the Directed Acyclic Graph (DAG), the following steps are performed within the <code>compile_packages_to_dag()</code> function:</p> <ul> <li> <p>The project name is obtained from the <code>pyproject.toml</code> file's <code>[\"project\"][\"name\"]</code> key.</p> </li> <li> <p>The logsheet metadata is obtained from the project's <code>package-settings.toml</code> file. <code>[\"outputs\"]</code> key is added to the logsheet, populated based on the <code>logsheet.headers</code> key from that file.</p> </li> <li> <p>The rest of the package's settings are obtained from the <code>package-settings.toml</code> file: <code>DATASET_FILE_SCHEMA</code>, <code>DATASET_SCHEMA</code>, <code>SAVE_DATA_FOLDER</code>, <code>RAW_DATA_FOLDER</code>.</p> </li> <li> <p>Get the package names from the all the folders within the <code>project_folder</code> and <code>packages_parent_folders</code> that begin with <code>ros-</code>.</p> </li> </ul> <p>Warning</p> <p>It is possible that <code>pyproject.toml</code> field and the folder name do not match, which could cause issues. </p> <p>In the future this discovery method should use the <code>pyproject.toml</code> files so that it is more robust and explicit, and uses the <code>pyproject.toml</code> file as the single source of truth.</p> <ul> <li> <p>Create the DAG for each individual package. The following types of nodes are added here, with connectivity-related metadata only: Runnables, Input Variables, and Output Variables. Minimum specifications for this step in the <code>.toml</code> files are:</p> <ul> <li>All Runnables:<ul> <li>\"inputs\": At least one input variable specified.</li> <li>Process:<ul> <li>\"outputs\": Can be an empty list, or a list of output variables.</li> </ul> </li> </ul> </li> </ul> </li> <li> <p>Get the bridges listed for each package from the package's <code>bridges.toml</code> file. The bridges are used to connect the packages together, and are applied in the topological order of the packages.</p> <ul> <li>This process converts Unspecified Input Variables to Dynamic Input Variables if a bridge exists for them. If not, they remain Unspecified.</li> </ul> </li> </ul>"},{"location":"Developer/Compilation/running/","title":"Running","text":"<p>The second step in compilation consists of adding all of the information needed for running each function.</p> <p>Note</p> <p>This page is a work in progress. The information here is incomplete and may be inaccurate.</p>"},{"location":"Developer/Nodes/","title":"Overview","text":"<p>The Directed Acyclic Graph (DAG) is comprised of nodes of various kinds:</p> <p>Runnables: These are the operations that are run in the pipeline. They can be processes, plots, or summaries.</p> <p>Variables: The data that is passed between the runnable nodes. Variables can be input or output variables.</p> <p>Note</p> <p>This page is a work in progress. The information here is incomplete and may be inaccurate.</p>"},{"location":"Developer/Nodes/Runnables/","title":"Overview","text":"<p>Runnables are the functions, visualizations, and summaries that comprise the Directed Acylic Graph.</p>"},{"location":"Developer/Nodes/Runnables/plot/","title":"Plot","text":"<p>A type of Runnable</p>"},{"location":"Developer/Nodes/Runnables/process/","title":"Process","text":"<p>A type of Runnable</p>"},{"location":"Developer/Nodes/Runnables/stats/","title":"Stats","text":"<p>A type of Runnable</p>"},{"location":"Developer/Nodes/Variables/","title":"Overview","text":"<p>Variable nodes represent the data that is passed between the Runnable nodes. Variables can be input or output variables, and are always connected to a Runnable node.</p>"},{"location":"Developer/Nodes/Variables/output_variables/","title":"Output Variables","text":"<p>Output variables represent the data that is being output from a process node. In the DAG, it connects to the subsequent input variables.</p> <p>Output variables are specified as a list of variable names in the <code>outputs</code> key of the process node in the .toml file. Because named output variables are typically not supported, the order of the variable names listed must match the order of the variables returned by the processing function. The names do not need to match the name of the variables returned, but the order must match. See below for an example: <pre><code>[example_process_name]\ninputs.input1 = \"input1\"\noutputs = [\"output1\", \"output2\"]\n</code></pre> This .toml file entry indicates that the example process returns two outputs, <code>output1</code> and <code>output2</code>, in that order.</p>"},{"location":"Developer/Nodes/Variables/Input%20Variables/","title":"Overview","text":"<p>Input variables represent the data that is flowing into a process, plot, or summary. They are always connected to a Runnable node. They can be specified in a variety of ways, including hard-coded values, dynamic variables, or variables that are passed from other processes. Input variables are specified using the \"inputs\" key with named keys for each corresponding input variable. In the below example, there are two inputs, <code>input1</code> and <code>input2</code>: <pre><code>[example_process_name]\ninputs.input1 = \"?\"\ninputs.input2 = \"?\"\noutputs = [\"output1\"]\n</code></pre></p>"},{"location":"Developer/Nodes/Variables/Input%20Variables/#unspecified-variables","title":"Unspecified Variables","text":"<p>Input variables that have the value <code>\"?\"</code> are considered unspecified. These variables are not connected to any other variable nodes in the package. By leaving the variable unspecified, package creators can leave the variable open for the user to specify using the <code>bridges.toml</code> file. If the variable is not specified in the <code>bridges.toml</code> file, the variable remains unspecified. See the above code block for an example of unspecified variables.</p>"},{"location":"Developer/Nodes/Variables/Input%20Variables/#dynamic-variables","title":"Dynamic Variables","text":"<p>To use the output of another function in the package as an input to a Runnable, the source Runnable's name &amp; output variable should be specified. This is done by setting the input variable to a string in the format <code>\"{runnable_name}.{output_variable}\"</code>. For example: <pre><code>[example_process_name]\ninputs.input1 = \"example_process_name1.output1\"\ninputs.input2 = \"example_process_name2.output1\"\noutputs = [\"output1\"]\n</code></pre> If there is no runnable and output variable by that name, then the string is treated as a hard-coded value.</p>"},{"location":"Developer/Nodes/Variables/Input%20Variables/#data-object-name","title":"Data Object Name","text":""},{"location":"Developer/Nodes/Variables/Input%20Variables/#data-object-file-path","title":"Data Object File Path","text":""},{"location":"Developer/Nodes/Variables/Input%20Variables/#hard-coded-variables","title":"Hard-Coded Variables","text":""},{"location":"Developer/Nodes/Variables/Input%20Variables/#value","title":"Value","text":"<p>If an input variable is a hard-coded value, a default value can be specified. For example: <pre><code>[example_process_name]\ninputs.input1 = \"hardcoded_value\"\noutputs = [\"output1\"]\n</code></pre> Note that frequently the user will want to change hard-coded values for \"what if\" analyses. This can be done by specifying the value in the <code>bridges.toml</code> file, which overwrites the value here.</p>"},{"location":"Developer/Nodes/Variables/Input%20Variables/#load-from-file","title":"Load from File","text":"<p>If a hardcoded variable is complex, or there are many versions of this hard-coded variable, it may be useful to load the variable from a file. JSON and TOML are supported. This can be done by specifying the input variable as a dictionary with the key <code>__load_file__</code> and the value as the file path relative to the project's root directory. For example: <pre><code>[example_process_name]\ninputs.input1 = {__load_file__ = \"constants/input1.json\"}\noutputs = [\"output1\"]\n</code></pre></p>"},{"location":"Developer/Nodes/Variables/Input%20Variables/dynamic/","title":"Dynamic","text":"<p>Input variables that are from the output of a prior Process.</p> <p>Note</p> <p>This page is a work in progress. The information here is incomplete and may be inaccurate.</p>"},{"location":"Developer/Nodes/Variables/Input%20Variables/hard_coded/","title":"Hard-Coded","text":"<p>Hard-coded variables specified by the user.</p> <p>Note</p> <p>This page is a work in progress. The information here is incomplete and may be inaccurate.</p>"},{"location":"Developer/Nodes/Variables/Input%20Variables/unspecified/","title":"Unspecified","text":"<p>Input variables that are not specified in the package itself because they are supposed to take input from another package.</p> <p>Note</p> <p>This page is a work in progress. The information here is incomplete and may be inaccurate.</p>"},{"location":"Developer/Package_Setup/","title":"Overview","text":"<p>Packages Overview</p>"},{"location":"Developer/Package_Setup/#terminology","title":"Terminology","text":"<p>Package: A folder called <code>&lt;name&gt;</code> generated from <code>ros create &lt;name&gt;</code> with the following folder structure. </p> <p>Package Names</p> <p>The package name must begin with <code>ros-</code> otherwise creating the package folder will fail.</p> <p>Project: A package folder in combination with a dataset to perform data analysis.</p> <p>Dataset: A logsheet &amp; data files.</p> <p>The dependencies for a specific package are specified in the package's <code>pyproject.toml</code> file, in the <code>dependencies</code> table, see below for a minimal working example:</p> <pre><code>[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[tool.researchos]\nindex = 'index.toml'\n\n[tool.hatch.build.targets.wheel]\npackages = [\"src\"]\n\n[project]\nname = \"test-project\"\nversion = \"0.0.1\"\nrequires-python = \"&gt;=3.7\"\nauthors = [\n    {name = \"Mitchell Tillman &lt;my.email@gmail.com&gt;\"},\n]\ndescription = \"Example Package\"\nreadme = \"README.md\"\ndependencies = [\n    \"ros-example-package\"\n]\n</code></pre> <p>This tells <code>pip</code> that the <code>ros-example-package</code> and all of its dependencies need to be installed when installing the <code>test-project</code> package.</p>"},{"location":"Developer/Package_Setup/discovery/","title":"Discovery","text":"<p>Packages are discovered within the current package's folder.</p>"},{"location":"Developer/Package_Setup/discovery/#discover_packages","title":"discover_packages","text":""},{"location":"Developer/Package_Setup/discovery/#inputs","title":"Inputs:","text":"<p>project_folder: The current package's root folder. Default: current directory</p> <p>parent_folders: The folders that may contain packages of interest. Default: current directory.</p>"},{"location":"Developer/Package_Setup/discovery/#outputs","title":"Outputs:","text":"<p>package_folders: The list of folders inside of the <code>project_folder</code> and <code>parent_folders</code> starting with <code>ros-</code>. This includes packages installed by <code>pip</code> and other package managers.</p> <p>Package Names</p> <p>The package names are defined in each package's <code>pyproject.toml</code> file's <code>[\"project\"][\"name\"]</code> tables.</p>"},{"location":"Developer/Running/","title":"Overview","text":"<p>Overview of the process of running the functions in the DAG.</p> <p>Note</p> <p>This page is a work in progress. The information here is incomplete and may be inaccurate.</p>"},{"location":"Developer/Running/running_runnables/","title":"Running a Runnable","text":"<p>Note</p> <p>This page is a work in progress. The information here is incomplete and may be inaccurate.</p>"},{"location":"Developer/Running/selecting_runnables/","title":"Selecting Runnables","text":"<p>Describes how the system knows which nodes in a DAG to run and which to skip.</p> <p>Note</p> <p>This page is a work in progress. The information here is incomplete and may be inaccurate.</p>"},{"location":"Home/","title":"Welcome to ResearchOS (pre-alpha version)","text":""},{"location":"Home/#introduction","title":"Introduction","text":"<p>Welcome to the documentation for ResearchOS, a Python package for scientific computing.</p>"},{"location":"Home/#project-description","title":"Project Description","text":"<p>Scientific computing is currently fractured, with many competing data standards (or lack thereof) and data processing tools that do not have a common way to communicate. ResearchOS provides a generalized framework to perform scientific computing of any kind, in a modular, easily shareable format.</p> <p>The primary innovation behind ResearchOS is to treat every single piece of the scientific data analysis workflow as an object, complete with ID and metadata. While this incurs some code overhead, the ability to have a standardized way to communicate between different parts of a pipeline and to share and integrate others' pipelines is invaluable, and sorely needed in the scientific computing community.</p>"}]}